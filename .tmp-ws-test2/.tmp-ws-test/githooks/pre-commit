#!/usr/bin/env bash
set -euo pipefail

# Orchestrator firewall integration: block orchestrator from committing when firewall is on
if [ -x "scripts/orchestrator_firewall.sh" ]; then
  ORCHESTRATION_ACTOR="${ORCHESTRATION_ACTOR:-unknown}" ./scripts/orchestrator_firewall.sh write repo || exit $?
fi

# Blocks commit if `.verified` is missing or older than staged file mtimes
ROOT_DIR="$(git rev-parse --show-toplevel)"
cd "$ROOT_DIR"

VERIFIED_FILE=".verified"

err() { echo "pre-commit: $*" >&2; }

if [ ! -f "$VERIFIED_FILE" ]; then
  err "Missing .verified — run: bash scripts/finalize.sh"
  exit 1
fi

# Ensure .verified indicates PASS
if ! grep -q '^status: PASS' "$VERIFIED_FILE"; then
  err ".verified does not indicate PASS — run: bash scripts/finalize.sh"
  exit 1
fi

# Cross-platform file mtime
file_mtime() {
  if stat -f %m "$1" >/dev/null 2>&1; then
    stat -f %m "$1"
  else
    stat -c %Y "$1"
  fi
}

VERIFIED_MTIME=$(file_mtime "$VERIFIED_FILE")

# Files staged for commit
STAGED=$(git diff --cached --name-only)

# If nothing is staged, allow commit (e.g., merging with no changes)
if [ -z "$STAGED" ]; then
  exit 0
fi

# Exclusions (files updated by finalize itself)
exclude_path() {
  case "$1" in
    .verified) return 0 ;;
    .orchestration/*) return 0 ;;
    *) return 1 ;;
  esac
}

STALE=0
while IFS= read -r f; do
  [ -e "$f" ] || continue
  if exclude_path "$f"; then
    continue
  fi
  FMTIME=$(file_mtime "$f")
  if [ "$FMTIME" -gt "$VERIFIED_MTIME" ]; then
    err "Stale verification: '$f' modified after .verified. Run finalize."
    STALE=1
  fi
done <<< "$STAGED"

if [ "$STALE" -eq 1 ]; then
  err "Commit blocked. Run: bash scripts/finalize.sh"
  exit 1
fi

exit 0
