{
  "file": "/Users/ramakrishnanannaswamy/projects/claude-self-reflect/mcp-server/src/server.py",
  "timestamp": "2025-09-14T20:49:41.049537",
  "language": "python",
  "engine": "ast-grep-py + unified registry",
  "registry_info": {
    "total_patterns_available": 35,
    "patterns_matched": 15,
    "patterns_errored": 1,
    "categories_found": [
      "python_async",
      "python_logging",
      "python_typing",
      "python_antipatterns",
      "python_catalog",
      "python_complexity"
    ]
  },
  "matches_by_category": {
    "python_async": [
      {
        "category": "python_async",
        "id": "async-function",
        "description": "Async function definition",
        "quality": "good",
        "weight": 2,
        "count": 5,
        "locations": [
          {
            "line": 224,
            "column": 0,
            "text": "async def get_import_stats():\n    \"\"\"Current import statistics and progress.\"\"\"\n"
          },
          {
            "line": 237,
            "column": 0,
            "text": "async def get_collection_list():\n    \"\"\"List of all Qdrant collections with meta"
          },
          {
            "line": 265,
            "column": 0,
            "text": "async def get_system_health():\n    \"\"\"System health and configuration informatio"
          },
          {
            "line": 357,
            "column": 0,
            "text": "async def update_indexing_status(cache_ttl: int = 5):\n    \"\"\"Update indexing sta"
          },
          {
            "line": 725,
            "column": 8,
            "text": "async def print_status():\n            await update_indexing_status()\n           "
          }
        ]
      },
      {
        "category": "python_async",
        "id": "await-call",
        "description": "Awaited async call",
        "quality": "neutral",
        "weight": 1,
        "count": 10,
        "locations": [
          {
            "line": 226,
            "column": 4,
            "text": "await update_indexing_status()"
          },
          {
            "line": 240,
            "column": 22,
            "text": "await qdrant_client.get_collections()"
          },
          {
            "line": 245,
            "column": 19,
            "text": "await qdrant_client.get_collection(collection_name=collection.name)"
          },
          {
            "line": 269,
            "column": 22,
            "text": "await qdrant_client.get_collections()"
          },
          {
            "line": 409,
            "column": 40,
            "text": "await asyncio.to_thread(read_json_file, path)"
          }
        ]
      }
    ],
    "python_logging": [
      {
        "category": "python_logging",
        "id": "logger-call",
        "description": "Logger usage",
        "quality": "good",
        "weight": 2,
        "count": 30,
        "locations": [
          {
            "line": 139,
            "column": 8,
            "text": "logger.info(f\"Embedding manager initialized: {embedding_manager.get_model_info()"
          },
          {
            "line": 149,
            "column": 8,
            "text": "logger.error(f\"Failed to initialize embeddings: {e}\")"
          },
          {
            "line": 155,
            "column": 0,
            "text": "logger.info(f\"MCP Server starting at {startup_time}\")"
          },
          {
            "line": 156,
            "column": 0,
            "text": "logger.info(f\"Python: {sys.version}\")"
          },
          {
            "line": 157,
            "column": 0,
            "text": "logger.info(f\"Working directory: {os.getcwd()}\")"
          }
        ]
      },
      {
        "category": "python_logging",
        "id": "print-call",
        "description": "Print statement",
        "quality": "bad",
        "weight": -1,
        "count": 1,
        "locations": [
          {
            "line": 734,
            "column": 12,
            "text": "print(json.dumps(status_copy, indent=2))"
          }
        ]
      }
    ],
    "python_typing": [
      {
        "category": "python_typing",
        "id": "typed-function",
        "description": "Function with return type",
        "quality": "good",
        "weight": 3,
        "count": 9,
        "locations": [
          {
            "line": 324,
            "column": 0,
            "text": "def normalize_path(path_str: str) -> str:\n    \"\"\"Normalize path for consistent c"
          },
          {
            "line": 339,
            "column": 0,
            "text": "def read_json_file(path: Path) -> dict:\n    \"\"\"Read JSON file from disk.\"\"\"\n    "
          },
          {
            "line": 345,
            "column": 0,
            "text": "def read_watcher_file(path: Path) -> dict:\n    \"\"\"Read watcher JSON file from di"
          },
          {
            "line": 351,
            "column": 0,
            "text": "def read_cloud_file(path: Path) -> dict:\n    \"\"\"Read cloud watcher JSON file fro"
          },
          {
            "line": 515,
            "column": 0,
            "text": "async def get_all_collections() -> List[str]:\n    \"\"\"Get all collections (both V"
          }
        ]
      },
      {
        "category": "python_typing",
        "id": "typed-async",
        "description": "Async function with return type",
        "quality": "good",
        "weight": 4,
        "count": 2,
        "locations": [
          {
            "line": 515,
            "column": 0,
            "text": "async def get_all_collections() -> List[str]:\n    \"\"\"Get all collections (both V"
          },
          {
            "line": 522,
            "column": 0,
            "text": "async def generate_embedding(text: str, force_type: Optional[str] = None) -> Lis"
          }
        ]
      },
      {
        "category": "python_typing",
        "id": "type-annotation",
        "description": "Variable type annotation",
        "quality": "good",
        "weight": 2,
        "count": 7,
        "locations": [
          {
            "line": 178,
            "column": 4,
            "text": "conversation_id: Optional[str] = None"
          },
          {
            "line": 179,
            "column": 4,
            "text": "base_conversation_id: Optional[str] = None"
          },
          {
            "line": 181,
            "column": 4,
            "text": "raw_payload: Optional[Dict[str, Any]] = None"
          },
          {
            "line": 183,
            "column": 4,
            "text": "code_patterns: Optional[Dict[str, List[str]]] = None"
          },
          {
            "line": 184,
            "column": 4,
            "text": "files_analyzed: Optional[List[str]] = None"
          }
        ]
      }
    ],
    "python_antipatterns": [
      {
        "category": "python_antipatterns",
        "id": "sync-open",
        "description": "Sync file open (should use aiofiles)",
        "quality": "bad",
        "weight": -3,
        "count": 3,
        "locations": [
          {
            "line": 341,
            "column": 9,
            "text": "open(path, 'r')"
          },
          {
            "line": 347,
            "column": 9,
            "text": "open(path, 'r')"
          },
          {
            "line": 353,
            "column": 9,
            "text": "open(path, 'r')"
          }
        ]
      },
      {
        "category": "python_antipatterns",
        "id": "global-var",
        "description": "Global variable usage",
        "quality": "bad",
        "weight": -2,
        "count": 3,
        "locations": [
          {
            "line": 136,
            "column": 4,
            "text": "global embedding_manager, voyage_client, local_embedding_model"
          },
          {
            "line": 364,
            "column": 4,
            "text": "global indexing_status, _indexing_cache"
          },
          {
            "line": 529,
            "column": 4,
            "text": "global embedding_manager, voyage_client, local_embedding_model"
          }
        ]
      }
    ],
    "python_catalog": [
      {
        "category": "python_catalog",
        "id": "optional-to-none-union",
        "description": "[PEP 604](https://peps.python.org/pep-0604/) recommends that `Type | None` is preferred over `Optional[Type]` for Python 3.10+.\n\nThis rule performs such rewriting. Note `Optional[$T]` alone is interpreted as subscripting expression instead of generic type, we need to use [pattern object](/guide/rule-config/atomic-rule.html#pattern-object) to disambiguate it with more context code.\n\n<!-- Use YAML in the example. Delete this section if use pattern. -->",
        "quality": "good",
        "weight": 3,
        "count": 8,
        "locations": [
          {
            "line": 178,
            "column": 21,
            "text": "Optional[str]"
          },
          {
            "line": 179,
            "column": 26,
            "text": "Optional[str]"
          },
          {
            "line": 181,
            "column": 17,
            "text": "Optional[Dict[str, Any]]"
          },
          {
            "line": 183,
            "column": 19,
            "text": "Optional[Dict[str, List[str]]]"
          },
          {
            "line": 184,
            "column": 20,
            "text": "Optional[List[str]]"
          }
        ]
      },
      {
        "category": "python_catalog",
        "id": "prefer-generator-expressions",
        "description": "List comprehensions like `[x for x in range(10)]` are a concise way to create lists in Python. However, we can achieve better memory efficiency by using generator expressions like `(x for x in range(10))` instead. List comprehensions create the entire list in memory, while generator expressions generate each element one at a time. We can make the change by replacing the square brackets with parentheses.",
        "quality": "good",
        "weight": 3,
        "count": 4075,
        "locations": [
          {
            "line": 1,
            "column": 0,
            "text": "\"\"\"Claude Reflect MCP Server with Memory Decay.\"\"\"\n\nimport os\nimport asyncio\nfro"
          },
          {
            "line": 1,
            "column": 0,
            "text": "\"\"\"Claude Reflect MCP Server with Memory Decay.\"\"\""
          },
          {
            "line": 1,
            "column": 0,
            "text": "\"\"\"Claude Reflect MCP Server with Memory Decay.\"\"\""
          },
          {
            "line": 1,
            "column": 0,
            "text": "\"\"\""
          },
          {
            "line": 1,
            "column": 3,
            "text": "Claude Reflect MCP Server with Memory Decay."
          }
        ]
      },
      {
        "category": "python_catalog",
        "id": "remove-async-def",
        "description": "The `async` keyword in Python is used to define asynchronous functions that can be `await`ed.\n\nIn this example, we want to remove the `async` keyword from a function definition and replace it with a synchronous version of the function. We also need to remove the `await` keyword from the function body.\n\nBy default, ast-grep will not apply overlapping replacements. This means `await` keywords will not be modified because they are inside the async function body.\n\nHowever, we can use the [`rewriter`](https://ast-grep.github.io/reference/yaml/rewriter.html) to apply changes inside the matched function body.",
        "quality": "good",
        "weight": 3,
        "count": 5,
        "locations": [
          {
            "line": 224,
            "column": 0,
            "text": "async def get_import_stats():\n    \"\"\"Current import statistics and progress.\"\"\"\n"
          },
          {
            "line": 237,
            "column": 0,
            "text": "async def get_collection_list():\n    \"\"\"List of all Qdrant collections with meta"
          },
          {
            "line": 265,
            "column": 0,
            "text": "async def get_system_health():\n    \"\"\"System health and configuration informatio"
          },
          {
            "line": 357,
            "column": 0,
            "text": "async def update_indexing_status(cache_ttl: int = 5):\n    \"\"\"Update indexing sta"
          },
          {
            "line": 725,
            "column": 8,
            "text": "async def print_status():\n            await update_indexing_status()\n           "
          }
        ]
      },
      {
        "category": "python_catalog",
        "id": "use-walrus-operator",
        "description": "The walrus operator (`:=`) introduced in Python 3.8 allows you to assign values to variables as part of an expression. This rule aims to simplify code by using the walrus operator in `if` statements.\n\nThis first part of the rule identifies cases where a variable is assigned a value and then immediately used in an `if` statement to control flow.",
        "quality": "good",
        "weight": 3,
        "count": 36,
        "locations": [
          {
            "line": 142,
            "column": 8,
            "text": "if embedding_manager.model_type == 'voyage':\n            voyage_client = embeddi"
          },
          {
            "line": 196,
            "column": 0,
            "text": "if CONNECTION_POOL_AVAILABLE and ENABLE_PARALLEL_SEARCH:\n    qdrant_pool = Qdran"
          },
          {
            "line": 218,
            "column": 0,
            "text": "if DECAY_MANAGER_AVAILABLE:\n    decay_manager = DecayManager()\n    logger.info(\""
          },
          {
            "line": 278,
            "column": 4,
            "text": "if embedding_manager:\n        embedding_info = {\n            \"model_type\": embed"
          },
          {
            "line": 333,
            "column": 4,
            "text": "if not path_str:\n        return path_str"
          }
        ]
      }
    ],
    "python_complexity": [
      {
        "category": "python_complexity",
        "id": "nested-loops",
        "description": "Nested loops (performance risk)",
        "quality": "bad",
        "weight": -3,
        "count": 1,
        "locations": [
          {
            "line": 600,
            "column": 12,
            "text": "for category, patterns in result.code_patterns.items():\n                if categ"
          }
        ]
      },
      {
        "category": "python_complexity",
        "id": "long-function",
        "description": "Long function (10+ statements)",
        "quality": "bad",
        "weight": -2,
        "count": 1,
        "locations": [
          {
            "line": 357,
            "column": 0,
            "text": "async def update_indexing_status(cache_ttl: int = 5):\n    \"\"\"Update indexing sta"
          }
        ]
      }
    ]
  },
  "all_matches": [
    {
      "category": "python_async",
      "id": "async-function",
      "description": "Async function definition",
      "quality": "good",
      "weight": 2,
      "count": 5,
      "locations": [
        {
          "line": 224,
          "column": 0,
          "text": "async def get_import_stats():\n    \"\"\"Current import statistics and progress.\"\"\"\n"
        },
        {
          "line": 237,
          "column": 0,
          "text": "async def get_collection_list():\n    \"\"\"List of all Qdrant collections with meta"
        },
        {
          "line": 265,
          "column": 0,
          "text": "async def get_system_health():\n    \"\"\"System health and configuration informatio"
        },
        {
          "line": 357,
          "column": 0,
          "text": "async def update_indexing_status(cache_ttl: int = 5):\n    \"\"\"Update indexing sta"
        },
        {
          "line": 725,
          "column": 8,
          "text": "async def print_status():\n            await update_indexing_status()\n           "
        }
      ]
    },
    {
      "category": "python_async",
      "id": "await-call",
      "description": "Awaited async call",
      "quality": "neutral",
      "weight": 1,
      "count": 10,
      "locations": [
        {
          "line": 226,
          "column": 4,
          "text": "await update_indexing_status()"
        },
        {
          "line": 240,
          "column": 22,
          "text": "await qdrant_client.get_collections()"
        },
        {
          "line": 245,
          "column": 19,
          "text": "await qdrant_client.get_collection(collection_name=collection.name)"
        },
        {
          "line": 269,
          "column": 22,
          "text": "await qdrant_client.get_collections()"
        },
        {
          "line": 409,
          "column": 40,
          "text": "await asyncio.to_thread(read_json_file, path)"
        }
      ]
    },
    {
      "category": "python_logging",
      "id": "logger-call",
      "description": "Logger usage",
      "quality": "good",
      "weight": 2,
      "count": 30,
      "locations": [
        {
          "line": 139,
          "column": 8,
          "text": "logger.info(f\"Embedding manager initialized: {embedding_manager.get_model_info()"
        },
        {
          "line": 149,
          "column": 8,
          "text": "logger.error(f\"Failed to initialize embeddings: {e}\")"
        },
        {
          "line": 155,
          "column": 0,
          "text": "logger.info(f\"MCP Server starting at {startup_time}\")"
        },
        {
          "line": 156,
          "column": 0,
          "text": "logger.info(f\"Python: {sys.version}\")"
        },
        {
          "line": 157,
          "column": 0,
          "text": "logger.info(f\"Working directory: {os.getcwd()}\")"
        }
      ]
    },
    {
      "category": "python_logging",
      "id": "print-call",
      "description": "Print statement",
      "quality": "bad",
      "weight": -1,
      "count": 1,
      "locations": [
        {
          "line": 734,
          "column": 12,
          "text": "print(json.dumps(status_copy, indent=2))"
        }
      ]
    },
    {
      "category": "python_typing",
      "id": "typed-function",
      "description": "Function with return type",
      "quality": "good",
      "weight": 3,
      "count": 9,
      "locations": [
        {
          "line": 324,
          "column": 0,
          "text": "def normalize_path(path_str: str) -> str:\n    \"\"\"Normalize path for consistent c"
        },
        {
          "line": 339,
          "column": 0,
          "text": "def read_json_file(path: Path) -> dict:\n    \"\"\"Read JSON file from disk.\"\"\"\n    "
        },
        {
          "line": 345,
          "column": 0,
          "text": "def read_watcher_file(path: Path) -> dict:\n    \"\"\"Read watcher JSON file from di"
        },
        {
          "line": 351,
          "column": 0,
          "text": "def read_cloud_file(path: Path) -> dict:\n    \"\"\"Read cloud watcher JSON file fro"
        },
        {
          "line": 515,
          "column": 0,
          "text": "async def get_all_collections() -> List[str]:\n    \"\"\"Get all collections (both V"
        }
      ]
    },
    {
      "category": "python_typing",
      "id": "typed-async",
      "description": "Async function with return type",
      "quality": "good",
      "weight": 4,
      "count": 2,
      "locations": [
        {
          "line": 515,
          "column": 0,
          "text": "async def get_all_collections() -> List[str]:\n    \"\"\"Get all collections (both V"
        },
        {
          "line": 522,
          "column": 0,
          "text": "async def generate_embedding(text: str, force_type: Optional[str] = None) -> Lis"
        }
      ]
    },
    {
      "category": "python_typing",
      "id": "type-annotation",
      "description": "Variable type annotation",
      "quality": "good",
      "weight": 2,
      "count": 7,
      "locations": [
        {
          "line": 178,
          "column": 4,
          "text": "conversation_id: Optional[str] = None"
        },
        {
          "line": 179,
          "column": 4,
          "text": "base_conversation_id: Optional[str] = None"
        },
        {
          "line": 181,
          "column": 4,
          "text": "raw_payload: Optional[Dict[str, Any]] = None"
        },
        {
          "line": 183,
          "column": 4,
          "text": "code_patterns: Optional[Dict[str, List[str]]] = None"
        },
        {
          "line": 184,
          "column": 4,
          "text": "files_analyzed: Optional[List[str]] = None"
        }
      ]
    },
    {
      "category": "python_antipatterns",
      "id": "sync-open",
      "description": "Sync file open (should use aiofiles)",
      "quality": "bad",
      "weight": -3,
      "count": 3,
      "locations": [
        {
          "line": 341,
          "column": 9,
          "text": "open(path, 'r')"
        },
        {
          "line": 347,
          "column": 9,
          "text": "open(path, 'r')"
        },
        {
          "line": 353,
          "column": 9,
          "text": "open(path, 'r')"
        }
      ]
    },
    {
      "category": "python_antipatterns",
      "id": "global-var",
      "description": "Global variable usage",
      "quality": "bad",
      "weight": -2,
      "count": 3,
      "locations": [
        {
          "line": 136,
          "column": 4,
          "text": "global embedding_manager, voyage_client, local_embedding_model"
        },
        {
          "line": 364,
          "column": 4,
          "text": "global indexing_status, _indexing_cache"
        },
        {
          "line": 529,
          "column": 4,
          "text": "global embedding_manager, voyage_client, local_embedding_model"
        }
      ]
    },
    {
      "category": "python_catalog",
      "id": "optional-to-none-union",
      "description": "[PEP 604](https://peps.python.org/pep-0604/) recommends that `Type | None` is preferred over `Optional[Type]` for Python 3.10+.\n\nThis rule performs such rewriting. Note `Optional[$T]` alone is interpreted as subscripting expression instead of generic type, we need to use [pattern object](/guide/rule-config/atomic-rule.html#pattern-object) to disambiguate it with more context code.\n\n<!-- Use YAML in the example. Delete this section if use pattern. -->",
      "quality": "good",
      "weight": 3,
      "count": 8,
      "locations": [
        {
          "line": 178,
          "column": 21,
          "text": "Optional[str]"
        },
        {
          "line": 179,
          "column": 26,
          "text": "Optional[str]"
        },
        {
          "line": 181,
          "column": 17,
          "text": "Optional[Dict[str, Any]]"
        },
        {
          "line": 183,
          "column": 19,
          "text": "Optional[Dict[str, List[str]]]"
        },
        {
          "line": 184,
          "column": 20,
          "text": "Optional[List[str]]"
        }
      ]
    },
    {
      "category": "python_catalog",
      "id": "prefer-generator-expressions",
      "description": "List comprehensions like `[x for x in range(10)]` are a concise way to create lists in Python. However, we can achieve better memory efficiency by using generator expressions like `(x for x in range(10))` instead. List comprehensions create the entire list in memory, while generator expressions generate each element one at a time. We can make the change by replacing the square brackets with parentheses.",
      "quality": "good",
      "weight": 3,
      "count": 4075,
      "locations": [
        {
          "line": 1,
          "column": 0,
          "text": "\"\"\"Claude Reflect MCP Server with Memory Decay.\"\"\"\n\nimport os\nimport asyncio\nfro"
        },
        {
          "line": 1,
          "column": 0,
          "text": "\"\"\"Claude Reflect MCP Server with Memory Decay.\"\"\""
        },
        {
          "line": 1,
          "column": 0,
          "text": "\"\"\"Claude Reflect MCP Server with Memory Decay.\"\"\""
        },
        {
          "line": 1,
          "column": 0,
          "text": "\"\"\""
        },
        {
          "line": 1,
          "column": 3,
          "text": "Claude Reflect MCP Server with Memory Decay."
        }
      ]
    },
    {
      "category": "python_catalog",
      "id": "remove-async-def",
      "description": "The `async` keyword in Python is used to define asynchronous functions that can be `await`ed.\n\nIn this example, we want to remove the `async` keyword from a function definition and replace it with a synchronous version of the function. We also need to remove the `await` keyword from the function body.\n\nBy default, ast-grep will not apply overlapping replacements. This means `await` keywords will not be modified because they are inside the async function body.\n\nHowever, we can use the [`rewriter`](https://ast-grep.github.io/reference/yaml/rewriter.html) to apply changes inside the matched function body.",
      "quality": "good",
      "weight": 3,
      "count": 5,
      "locations": [
        {
          "line": 224,
          "column": 0,
          "text": "async def get_import_stats():\n    \"\"\"Current import statistics and progress.\"\"\"\n"
        },
        {
          "line": 237,
          "column": 0,
          "text": "async def get_collection_list():\n    \"\"\"List of all Qdrant collections with meta"
        },
        {
          "line": 265,
          "column": 0,
          "text": "async def get_system_health():\n    \"\"\"System health and configuration informatio"
        },
        {
          "line": 357,
          "column": 0,
          "text": "async def update_indexing_status(cache_ttl: int = 5):\n    \"\"\"Update indexing sta"
        },
        {
          "line": 725,
          "column": 8,
          "text": "async def print_status():\n            await update_indexing_status()\n           "
        }
      ]
    },
    {
      "category": "python_catalog",
      "id": "use-walrus-operator",
      "description": "The walrus operator (`:=`) introduced in Python 3.8 allows you to assign values to variables as part of an expression. This rule aims to simplify code by using the walrus operator in `if` statements.\n\nThis first part of the rule identifies cases where a variable is assigned a value and then immediately used in an `if` statement to control flow.",
      "quality": "good",
      "weight": 3,
      "count": 36,
      "locations": [
        {
          "line": 142,
          "column": 8,
          "text": "if embedding_manager.model_type == 'voyage':\n            voyage_client = embeddi"
        },
        {
          "line": 196,
          "column": 0,
          "text": "if CONNECTION_POOL_AVAILABLE and ENABLE_PARALLEL_SEARCH:\n    qdrant_pool = Qdran"
        },
        {
          "line": 218,
          "column": 0,
          "text": "if DECAY_MANAGER_AVAILABLE:\n    decay_manager = DecayManager()\n    logger.info(\""
        },
        {
          "line": 278,
          "column": 4,
          "text": "if embedding_manager:\n        embedding_info = {\n            \"model_type\": embed"
        },
        {
          "line": 333,
          "column": 4,
          "text": "if not path_str:\n        return path_str"
        }
      ]
    },
    {
      "category": "python_complexity",
      "id": "nested-loops",
      "description": "Nested loops (performance risk)",
      "quality": "bad",
      "weight": -3,
      "count": 1,
      "locations": [
        {
          "line": 600,
          "column": 12,
          "text": "for category, patterns in result.code_patterns.items():\n                if categ"
        }
      ]
    },
    {
      "category": "python_complexity",
      "id": "long-function",
      "description": "Long function (10+ statements)",
      "quality": "bad",
      "weight": -2,
      "count": 1,
      "locations": [
        {
          "line": 357,
          "column": 0,
          "text": "async def update_indexing_status(cache_ttl: int = 5):\n    \"\"\"Update indexing sta"
        }
      ]
    }
  ],
  "errors": [
    {
      "pattern_id": "specific-except",
      "category": "python_error_handling",
      "error": "cannot get matcher\n\nCaused by:\n    0: `rule` is not configured correctly.\n    1: Rule contains invalid pattern matcher.\n    2: Multiple AST nodes are detected. Please check the pattern source `except "
    }
  ],
  "quality_metrics": {
    "quality_score": 0.586,
    "good_patterns_found": 4177,
    "bad_patterns_found": 9,
    "unique_patterns_matched": 15,
    "total_issues": 9,
    "total_good_practices": 4177
  },
  "recommendations": [
    "\ud83d\udfe1 Warning: Several anti-patterns detected",
    "Replace 1 print statements with logger",
    "Fix 6 anti-patterns in python_antipatterns"
  ]
}